// Generated by CoffeeScript 1.6.3
(function() {
  var Branch, Promise, adapter, isFunction, isPromise, p,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  isFunction = function(x) {
    return typeof x === "function";
  };

  isPromise = function(x) {
    return x.constructor === Promise;
  };

  Branch = (function() {
    function Branch(onFulfilled, onRejected) {
      this.onFulfilled = onFulfilled;
      this.onRejected = onRejected;
      this.promise = new Promise();
    }

    Branch.prototype.fulfill = function(value) {
      var nextValue, reason;
      nextValue = value;
      if (isFunction(this.onFulfilled)) {
        try {
          nextValue = this.onFulfilled(value);
        } catch (_error) {
          reason = _error;
          return this.promise.reject(reason);
        }
      }
      return this.promise.resolve(nextValue);
    };

    Branch.prototype.reject = function(reason) {
      var nextReason, nextValue;
      nextValue = void 0;
      if (isFunction(this.onRejected)) {
        try {
          nextValue = this.onRejected(reason);
        } catch (_error) {
          nextReason = _error;
          return this.promise.reject(nextReason);
        }
        return this.promise.resolve(nextValue);
      } else {
        return this.promise.reject(reason);
      }
    };

    return Branch;

  })();

  Promise = (function() {
    function Promise(impl) {
      this.reject = __bind(this.reject, this);
      this.fulfill = __bind(this.fulfill, this);
      this.resolve = __bind(this.resolve, this);
      this.branches = [];
      this.state = 'pending';
      if (typeof impl === "function") {
        impl(this.resolve, this.reject);
      }
    }

    Promise.prototype.resolve = function(val) {
      return this.fulfill(val);
    };

    Promise.prototype.fulfill = function(value) {
      var _this = this;
      if (this.state === 'pending') {
        this.value = value;
        this.state = 'fulfilled';
        return setTimeout(function() {
          var branch, _i, _len, _ref, _results;
          _ref = _this.branches;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            branch = _ref[_i];
            _results.push(branch.fulfill(value));
          }
          return _results;
        });
      }
    };

    Promise.prototype.reject = function(reason) {
      var _this = this;
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        return setTimeout(function() {
          var branch, _i, _len, _ref, _results;
          _ref = _this.branches;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            branch = _ref[_i];
            _results.push(branch.reject(reason));
          }
          return _results;
        });
      }
    };

    Promise.prototype.then = function(onFulfilled, onRejected) {
      var branch,
        _this = this;
      branch = new Branch(onFulfilled, onRejected);
      if (this.state === 'fulfilled') {
        setTimeout(function() {
          return branch.fulfill(_this.value);
        });
      } else if (this.state === 'rejected') {
        setTimeout(function() {
          return branch.reject(_this.reason);
        });
      } else {
        this.branches.push(branch);
      }
      return branch.promise;
    };

    return Promise;

  })();

  p = new Promise(function(resolve, reject) {
    return setTimeout(function() {
      return resolve(3);
    });
  });

  p.then(function(val) {
    console.log('val', val);
    throw 4;
  }).then(null, function(val) {
    console.log('val2', val);
    return 5;
  });

  adapter = {};

  adapter.fulfilled = function(value) {
    return new Promise(function(resolve, reject) {
      return resolve(value);
    });
  };

  adapter.rejected = function(error) {
    return new Promise(function(resolve, reject) {
      return reject(error);
    });
  };

  adapter.pending = function() {
    var pending;
    pending = {};
    pending.promise = new Promise(function(resolve, reject) {
      pending.fulfill = resolve;
      return pending.reject = reject;
    });
    return pending;
  };

  module.exports = global.adapter = adapter;

}).call(this);
